################################################################################
# Copyright 2016 Indiana University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

#' Runs all of the sparse matrix microbenchmarks
#'
#' \code{SparseMatrixBenchmark} runs all of the microbenchmarks for performance
#'   testing the sparse matrix linear algebra kernels
#'
#' This function runs the sparse matrix microbenchmarks defined in the
#' \code{matrixVectorMicrobenchmarks}, \code{choleskyMicrobenchmarks}, 
#' \code{luMicrobenchmarks}, and \code{qrMicrobenchmarks} input vectors
#' For each microbenchmark, it creates a
#' seperate output file in CSV format containing the performance results for
#' each matrix tested by the microbenchmark.  The names of the output files
#' follow the format \code{csvResultsBaseFileName}_\code{runIdentifier}.csv,
#' where \code{csvResultsBaseFileName} is specified in the
#' \code{SparseMatrixMicrobenchmark} object of each microbenchmark and
#' \code{runIdentifier} is an input parameter to this function.  Each
#' input vector contains instances of the \code{SparseMatrixMicrobenchmark}
#' class defining each microbenchmark.  Each microbenchmark object with the
#' \code{active} field set to TRUE will be executed.  The vectors of default
#' microbenchmarks are generated by the functions
#' \code{\link{SparseMatrixVectorDefaultMicrobenchmarks}},
#' \code{\link{SparseCholeskyDefaultMicrobenchmarks}},
#' \code{\link{SparseLuDefaultMicrobenchmarks}}, and
#' \code{\link{SparseQrDefaultMicrobenchmarks}}.
#'
#' @param runIdentifier a character string specifying the suffix to be
#'   appended to the base of the file name of the output CSV format files
#' @param matrixDirectory a character string specifying the directory that
#'   the sparse matrices will be read from
#' @param resultsDirectory a character string specifying the directory
#'   where all of the CSV performance results files will be saved
#' @param matrixVectorMicrobenchmarks a vector of
#'   \code{SparseMatrixMicrobenchmark} objects defining the matrix-vector
#'   multiplication microbenchmarks to execute as part of the sparse matrix
#'   benchmark.  Default values are provided by the function
#'   \code{\link{SparseMatrixVectorDefaultMicrobenchmarks}}.
#' @param choleskyMicrobenchmarks a vector of
#'   \code{SparseMatrixMicrobenchmark} objects defining the Cholesky
#'   factorization microbenchmarks to execute as part of the sparse matrix
#'   benchmark.  Default values are provided by the function
#'   \code{\link{SparseCholeskyDefaultMicrobenchmarks}}.
#' @param luMicrobenchmarks a vector of \code{SparseMatrixMicrobenchmark}
#'   objects defining the LU factorization microbenchmarks to execute as part
#'   of the sparse matrix benchmark.  Default values are provided by the
#'   function \code{\link{SparseLuDefaultMicrobenchmarks}}.
#' @param qrMicrobenchmarks a vector of \code{SparseMatrixMicrobenchmark}
#'   objects defining the QR factorization microbenchmarks to execute as part
#'   of the sparse matrix benchmark.  Default values are provided by the
#'   function \code{\link{SparseQrDefaultMicrobenchmarks}}.
#' @examples 
#' ## Run the default sparse matrix benchmarks and place the results files
#' ## in the directory ./SparseMatrixResults with the run identifier test1
#' ## as a suffix to the base of the CSV file names
#' SparseMatrixBenchmark("test1", "./SparseMatrixResults")
#'
#' ## Run the default sparse matrix benchmark with the circuit5M_dc QR
#' ## decomposition microbenchmark disabled
#' qrMicrobenchmarks <- SparseQrDefaultMicrobenchmarks()
#' qrMicrobenchmarks[["circuit5M_dc"]]$active <- FALSE
#' SparseMatrixBenchmark("test1", "./DenseMatrixResults")
SparseMatrixBenchmark <- function(runIdentifier, matrixDirectory,
   resultsDirectory,
   matrixVectorMicrobenchmarks = SparseMatrixVectorDefaultMicrobenchmarks(),
   choleskyMicrobenchmarks = SparseCholeskyDefaultMicrobenchmarks(),
   luMicrobenchmarks = SparseLuDefaultMicrobenchmarks(),
   qrMicrobenchmarks = SparseQrDefaultMicrobenchmarks()) {

   numberOfThreads <- strtoi(GetConfigurableEnvParameter("R_BENCH_NUM_THREADS_VARIABLE"))

   # Loop over all sparse matrix-vector multiplication microbenchmarks

   for (i in 1:length(matrixVectorMicrobenchmarks)) {
      if (matrixVectorMicrobenchmarks[[i]]$active) {
         # TODO: need to make the matrix directory a field in the microbenchmark
         # classes, and to make the directory for the default matrices an
         # environment parameter read during package initialization.

         # The matrices are read in to the global environment so that they only
         # have to be read from storage once.
         matrixFileName <- file.path(matrixDirectory, matrixVectorMicrobenchmarks[[i]]$matrixFileName)
         load(matrixFileName, envir = .GlobalEnv)
         returnValue <- MicrobenchmarkSparseMatrixKernel(matrixVectorMicrobenchmarks[[i]], numberOfThreads, resultsDirectory, runIdentifier)
         remove(list=c(matrixVectorMicrobenchmarks[[i]]$matrixObjectName), envir = .GlobalEnv)
         invisible(gc())
      }
   }


   # Loop over all sparse Cholesky factorization microbenchmarks

   for (i in 1:length(choleskyMicrobenchmarks)) {
      if (choleskyMicrobenchmarks[[i]]$active) {
         # The matrices are read in to the global environment so that they only
         # have to be read from storage once.
         matrixFileName <- file.path(matrixDirectory, choleskyMicrobenchmarks[[i]]$matrixFileName)
         load(matrixFileName, envir = .GlobalEnv)
         returnValue <- MicrobenchmarkSparseMatrixKernel(choleskyMicrobenchmarks[[i]], numberOfThreads, resultsDirectory, runIdentifier)
         remove(list=c(choleskyMicrobenchmarks[[i]]$matrixObjectName), envir = .GlobalEnv)
         invisible(gc())
      }
   }


   # Loop over all sparse LU factorization microbenchmarks

   for (i in 1:length(luMicrobenchmarks)) {
      if (luMicrobenchmarks[[i]]$active) {
         # The matrices are read in to the global environment so that they only
         # have to be read from storage once.
         matrixFileName <- file.path(matrixDirectory, luMicrobenchmarks[[i]]$matrixFileName)
         load(matrixFileName, envir = .GlobalEnv)
         returnValue <- MicrobenchmarkSparseMatrixKernel(luMicrobenchmarks[[i]], numberOfThreads, resultsDirectory, runIdentifier)
         remove(list=c(luMicrobenchmarks[[i]]$matrixObjectName), envir = .GlobalEnv)
         invisible(gc())
      }
   }

   # Loop over all sparse QR factorization microbenchmarks

   for (i in 1:length(qrMicrobenchmarks)) {
      if (qrMicrobenchmarks[[i]]$active) {
         # The matrices are read in to the global environment so that they only
         # have to be read from storage once.
         matrixFileName <- file.path(matrixDirectory, qrMicrobenchmarks[[i]]$matrixFileName)
         load(matrixFileName, envir = .GlobalEnv)
         returnValue <- MicrobenchmarkSparseMatrixKernel(qrMicrobenchmarks[[i]], numberOfThreads, resultsDirectory, runIdentifier)
         remove(list=c(qrMicrobenchmarks[[i]]$matrixObjectName), envir = .GlobalEnv)
         invisible(gc())
      }
   }

}


#' Initializes the vector of default sparse matrix-vector microbenchmarks
#'
#' \code{SparseMatrixVectorDefaultMicrobenchmarks} defines the default sparse
#' matrix-vector microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse
#' matrix-vector microbenchmarks cover a variety of matrices of different
#' dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item laplacian7pt_100 -- 100x100x100 7-point Laplacian operator
#'   \item laplacian7pt_200 -- 200x200x200 7-point Laplacian operator
#'   \item ca2010 -- DIMACS10/ca2010 710145x710145 undirected graph matrix
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerate
#'   in the description.
SparseMatrixVectorDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["laplacian7pt_100"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse matrix-vector mult. with 100x100x100 7-point Laplacian operator",
      description = "Sparse matrix-vector multiplication with 100x100x100 7-point Laplacian operator",
      matrixFileName = "laplacian7pt_100_R",
      csvResultsBaseFileName = "matvec_laplacian7pt_100",
      matrixObjectName = "laplacian7pt_100",
      numberOfRows = as.integer(1000000),
      numberOfColumns = as.integer(1000000),
      numberOfNonzeros = as.integer(6940000),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseMatrixVectorAllocator,
      benchmarkFunction = SparseMatrixVectorBenchmark
   )

   microbenchmarks[["laplacian7pt_200"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse matrix-vector mult. with 200x200x200 7-point Laplacian operator",
      description = "Sparse matrix-vector multiplication with 200x200x200 7-point Laplacian operator",
      matrixFileName = "laplacian7pt_200_R",
      csvResultsBaseFileName = "matvec_laplacian7pt_200",
      matrixObjectName = "laplacian7pt_200",
      numberOfRows = as.integer(8000000),
      numberOfColumns = as.integer(8000000),
      numberOfNonzeros = as.integer(55760000),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseMatrixVectorAllocator,
      benchmarkFunction = SparseMatrixVectorBenchmark
   )   

   microbenchmarks[["ca2010"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse matrix-vector mult. with DIMACS10/ca2010 undirected graph matrix",
      description = "Sparse matrix-vector mult. with undirected weighted graph matrix ca2010 from the University of Florida Sparse Matrix Collection DIMACS10 matrix group",
      matrixFileName = "ca2010_R",
      csvResultsBaseFileName = "matvec_ca2010",
      matrixObjectName = "ca2010",
      numberOfRows = as.integer(710145),
      numberOfColumns = as.integer(710145),
      numberOfNonzeros = as.integer(3489366),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseMatrixVectorAllocator,
      benchmarkFunction = SparseMatrixVectorBenchmark
   )

   return (microbenchmarks)
}


#' Initializes the vector of default sparse Cholesky factorization
#' microbenchmarks
#'
#' \code{SparseCholeskyDefaultMicrobenchmarks} defines the default sparse
#' Cholesky factorization microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse
#' Cholesky factorization microbenchmarks cover a variety of matrices of
#' different dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item ct20stif -- Boeing structural matrix with 2600295 nonzeros
#'   \item Andrews -- computer vision matrix with 760154
#'   \item G3_circuit -- AMD circuit simulation matrix with 7660826 nonzeros
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerated
#'   in the description.
SparseCholeskyDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["ct20stif"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse Cholesky factorization of Boeing/ct20stif structural problem matrix",
      description = "Cholesky factorization of ct20stif matrix from University of Florida Sparse Matrix Collection Boeing group; CT20 engine block -- stiffness matrix, Boeing",
      matrixFileName = "ct20stif_R",
      csvResultsBaseFileName = "cholesky_ct20stif",
      matrixObjectName = "ct20stif",
      numberOfRows = as.integer(52329),
      numberOfColumns = as.integer(52329),
      numberOfNonzeros = as.integer(2600295),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseCholeskyAllocator,
      benchmarkFunction = SparseCholeskyBenchmark
   )

   microbenchmarks[["Andrews"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse Cholesky factorization of Andrews/Andrews computer graphics vision problem matrix",
      description = "Cholesky factorization of Andrews matrix from University of Florida Sparse Matrix Collection Andrews group; Eigenvalue problem, Stuart Andrews, Brown Univ.",
      matrixFileName = "Andrews_R",
      csvResultsBaseFileName = "cholesky_Andrews",
      matrixObjectName = "Andrews",
      numberOfRows = as.integer(60000),
      numberOfColumns = as.integer(60000),
      numberOfNonzeros = as.integer(760154),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseCholeskyAllocator,
      benchmarkFunction = SparseCholeskyBenchmark
   )

   microbenchmarks[["G3_circuit"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse Cholesky factorization of AMD/G3_circuit circuit simulation problem matrix",
      description = "Cholesky factorization of G3_circuit matrix from University of Florida Sparse Matrix Collection AMD group; circuit simulation problem, Ufuk Okuyucu, AMD, Inc.",
      matrixFileName = "G3_circuit_R",
      csvResultsBaseFileName = "cholesky_G3_circuit",
      matrixObjectName = "G3_circuit",
      numberOfRows = as.integer(1585478),
      numberOfColumns = as.integer(1585478),
      numberOfNonzeros = as.integer(7660826),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseCholeskyAllocator,
      benchmarkFunction = SparseCholeskyBenchmark
   )

   return (microbenchmarks)
}


#' Initializes the vector of default sparse LU factorization microbenchmarks
#'
#' \code{SparseLuDefaultMicrobenchmarks} defines the default sparse LU
#' factorization microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse LU
#' factorization microbenchmarks cover a variety of matrices of different
#' dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item circuit5M_dc -- Freescale DC circuit simulation matrix 2600295 nonzeros
#'   \item stomach -- 3D electro-physical model matrix with 3021648 nonzeros
#'   \item torso3 -- 3D electro-physical model matrix with 4429042 nonzeros
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerated
#'   in the description.
SparseLuDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["circuit5M_dc"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse LU decomposition of Freescale/circuit5M_dc circuit simulation problem matrix",
      description = "LU decomposition of circuit5M_dc matrix from University of Florida Sparse Matrix Collection Freescale group; Large circuit (DC analysis) K. Gullapalli, Freescale Semiconductor",
      matrixFileName = "circuit5M_dc_R",
      csvResultsBaseFileName = "lu_circuit5M_dc",
      matrixObjectName = "circuit5M_dc",
      numberOfRows = as.integer(3523317),
      numberOfColumns = as.integer(3523317),
      numberOfNonzeros = as.integer(14865409),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseLuAllocator,
      benchmarkFunction = SparseLuBenchmark
   )

   microbenchmarks[["stomach"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse LU decomposition of Norris/stomach 2D/3D problem matrix",
      description = "LU decomposition of stomach matrix from University of Florida Sparse Matrix Collection Norris group; S.Norris, Univ. Auckland. 3D electro-physical model of a duodenum",
      matrixFileName = "stomach_R",
      csvResultsBaseFileName = "lu_stomach",
      matrixObjectName = "stomach",
      numberOfRows = as.integer(213360),
      numberOfColumns = as.integer(213360),
      numberOfNonzeros = as.integer(3021648),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseLuAllocator,
      benchmarkFunction = SparseLuBenchmark
   )

   microbenchmarks[["torso3"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse LU decomposition of Norris/torso3 2D/3D problem matrix",
      description = "LU decomposition of torso3 matrix from University of Florida Sparse Matrix Collection Norris group; S.Norris, Univ Auckland. finite diff. electro-phys.  3D model of torso",
      matrixFileName = "torso3_R",
      csvResultsBaseFileName = "lu_torso3",
      matrixObjectName = "torso3",
      numberOfRows = as.integer(259156),
      numberOfColumns = as.integer(259156),
      numberOfNonzeros = as.integer(4429042),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseLuAllocator,
      benchmarkFunction = SparseLuBenchmark
   )

   return (microbenchmarks)
}


#' Initializes the vector of default sparse QR factorization microbenchmarks
#'
#' \code{SparseQrDefaultMicrobenchmarks} defines the default sparse QR
#' factorization microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse QR
#' factorization microbenchmarks cover a variety of matrices of different
#' dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item Maragal_6 -- rank deficient least squares matrix of 537694 nonzeros
#'   \item landmark -- least squares matrix of 1146848
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerated
#'   in the description.
SparseQrDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["Maragal_6"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse QR factorization of NYPA/Maragal_6 least squares problem matrix",
      description = "QR factorization of Maragal_6 matrix from University of Florida Sparse Matrix Collection NYPA group; rank deficient least squares problem, D. Maragal, NY Power Authority",
      matrixFileName = "Maragal_6",
      csvResultsBaseFileName = "qr_Maragal_6",
      matrixObjectName = "Maragal_6",
      numberOfRows = as.integer(21255),
      numberOfColumns = as.integer(10152),
      numberOfNonzeros = as.integer(537694),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseQrAllocator,
      benchmarkFunction = SparseQrBenchmark
   )

   microbenchmarks[["landmark"]] <- SparseMatrixMicrobenchmark$new(
      active = TRUE,
      benchmarkName = "sparse QR factorization of Pereyra/landmark least squares problem matrix",
      description = "QR factorization of landmark matrix from University of Florida Sparse Matrix Collection Pereyra group; Matrix from Victor Pereyra, Stanford University",
      matrixFileName = "landmark_R",
      csvResultsBaseFileName = "qr_landmark",
      matrixObjectName = "landmark",
      numberOfRows = as.integer(71952),
      numberOfColumns = as.integer(2704),
      numberOfNonzeros = as.integer(1146848),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseQrAllocator,
      benchmarkFunction = SparseQrBenchmark
   )

   return (microbenchmarks)
}

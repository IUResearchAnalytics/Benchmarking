################################################################################
# Copyright 2016 Indiana University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

#' Runs all of the sparse matrix microbenchmarks
#'
#' \code{SparseMatrixBenchmark} runs all of the microbenchmarks for performance
#'   testing the sparse matrix linear algebra kernels
#'
#' This function runs the sparse matrix microbenchmarks, which are divided
#' into four categories supported by this benchmark, defined in the
#' \code{matrixVectorMicrobenchmarks}, \code{choleskyMicrobenchmarks}, 
#' \code{luMicrobenchmarks}, and \code{qrMicrobenchmarks} input vectors
#' For each microbenchmark, it creates a
#' seperate output file in CSV format containing the performance results for
#' each matrix tested by the microbenchmark.  The names of the output files
#' follow the format \code{csvResultsBaseFileName}_\code{runIdentifier}.csv,
#' where \code{csvResultsBaseFileName} is specified in the
#' \code{SparseMatrixMicrobenchmark} object of each microbenchmark and
#' \code{runIdentifier} is an input parameter to this function.  Each
#' input vector contains instances of the
#' \code{\link{SparseMatrixMicrobenchmark}} class defining each microbenchmark.
#' Each microbenchmark object with the
#' \code{active} field set to TRUE will be executed.  The vectors of default
#' microbenchmarks are generated by the functions
#' \code{\link{SparseMatrixVectorDefaultMicrobenchmarks}},
#' \code{\link{SparseCholeskyDefaultMicrobenchmarks}},
#' \code{\link{SparseLuDefaultMicrobenchmarks}}, and
#' \code{\link{SparseQrDefaultMicrobenchmarks}}.  Each 
#' \code{SparseMatrixMicrobenchmark} specifies an R data file which contains the
#' sparse matrix object needed by the microbenchmark.  The needed R data files
#' should either be given in an attached R package or given in the \code{data}
#' subdirectory of the current working directory, and they should have the
#' extension \code{.RData}.
#'
#' @param runIdentifier a character string specifying the suffix to be
#'   appended to the base of the file name of the output CSV format files
#' @param resultsDirectory a character string specifying the directory
#'   where all of the CSV performance results files will be saved
#' @param matrixVectorMicrobenchmarks a vector of
#'   \code{SparseMatrixMicrobenchmark} objects defining the matrix-vector
#'   multiplication microbenchmarks to execute as part of the sparse matrix
#'   benchmark.  Default values are provided by the function
#'   \code{\link{SparseMatrixVectorDefaultMicrobenchmarks}}.
#' @param choleskyMicrobenchmarks a vector of
#'   \code{SparseMatrixMicrobenchmark} objects defining the Cholesky
#'   factorization microbenchmarks to execute as part of the sparse matrix
#'   benchmark.  Default values are provided by the function
#'   \code{\link{SparseCholeskyDefaultMicrobenchmarks}}.
#' @param luMicrobenchmarks a vector of \code{SparseMatrixMicrobenchmark}
#'   objects defining the LU factorization microbenchmarks to execute as part
#'   of the sparse matrix benchmark.  Default values are provided by the
#'   function \code{\link{SparseLuDefaultMicrobenchmarks}}.
#' @param qrMicrobenchmarks a vector of \code{SparseMatrixMicrobenchmark}
#'   objects defining the QR factorization microbenchmarks to execute as part
#'   of the sparse matrix benchmark.  Default values are provided by the
#'   function \code{\link{SparseQrDefaultMicrobenchmarks}}.
#' @return a list of data frames, one data frame for each supported
#'   category of sparse matrix microbenchmarks, with each data frame
#'   containing the dimensions of the sparse matrix tested and the user,
#'   system, and elapsed (wall clock) time of times of each performance
#'   trial
#'   
#' @examples 
#' ## Run the default sparse matrix microbenchmarks and place the results files
#' ## in the directory ./SparseMatrixResults with the run identifier test1
#' ## as a suffix to the base of the CSV file names
#' #SparseMatrixBenchmark("test1", "./SparseMatrixResults")
#'
#' ## Run the default sparse matrix benchmark with the circuit5M_dc QR
#' ## decomposition microbenchmark disabled
#' #qrMicrobenchmarks <- SparseQrDefaultMicrobenchmarks()
#' #qrMicrobenchmarks[["circuit5M_dc"]]$active <- FALSE
#' #SparseMatrixBenchmark("test1", "./SparseMatrixResults")
#' @seealso \code{\link{SparseMatrixVectorDefaultMicrobenchmarks}}
#'          \code{\link{SparseCholeskyDefaultMicrobenchmarks}}
#'          \code{\link{SparseLuDefaultMicrobenchmarks}}
#'          \code{\link{SparseQrDefaultMicrobenchmarks}}
#' @export
SparseMatrixBenchmark <- function(runIdentifier,
   resultsDirectory,
   matrixVectorMicrobenchmarks = SparseMatrixVectorDefaultMicrobenchmarks(),
   choleskyMicrobenchmarks = SparseCholeskyDefaultMicrobenchmarks(),
   luMicrobenchmarks = SparseLuDefaultMicrobenchmarks(),
   qrMicrobenchmarks = SparseQrDefaultMicrobenchmarks()) {

   numberOfThreads <- strtoi(GetConfigurableEnvParameter("R_BENCH_NUM_THREADS_VARIABLE"))

   allResults <- list()
   matrixVectorResults <- list()
   choleskyResults <- list()
   luResults <- list()
   qrResults <- list()

   # Loop over all sparse matrix-vector multiplication microbenchmarks
   if (length(matrixVectorMicrobenchmarks) > 0) {
      matrixVectorResults <- PerformSparseMatrixKernelMicrobenchmarking(matrixVectorMicrobenchmarks, numberOfThreads, runIdentifier, resultsDirectory)
   } else {
      cat(sprintf("WARN: no sparse matrix-vector multiplication microbenchmarks to execute, skipping\n\n"))
   }

   # Loop over all sparse Cholesky factorization microbenchmarks
   if (length(choleskyMicrobenchmarks) > 0) {
      choleskyResults <- PerformSparseMatrixKernelMicrobenchmarking(choleskyMicrobenchmarks, numberOfThreads, runIdentifier, resultsDirectory)
   } else {
      cat(sprintf("WARN: no sparse Cholesky factorization microbenchmarks to execute, skipping\n\n"))
   }

   # Loop over all sparse LU factorization microbenchmarks
   if (length(luMicrobenchmarks) > 0) {
      luResults <- PerformSparseMatrixKernelMicrobenchmarking(luMicrobenchmarks, numberOfThreads, runIdentifier, resultsDirectory)
   } else {
      cat(sprintf("WARN: no sparse LU factorization microbenchmarks to execute, skipping\n\n"))
   }

   # Loop over all sparse QR factorization microbenchmarks
   if (length(qrMicrobenchmarks)) {
      qrResults <- PerformSparseMatrixKernelMicrobenchmarking(qrMicrobenchmarks, numberOfThreads, runIdentifier, resultsDirectory)
   } else {
      cat(sprintf("WARN: no sparse QR factorization microbenchmarks to execute, skipping\n\n"))
   }

   allResults[["matrixVectorResults"]] <- matrixVectorResults
   allResults[["choleskyResults"]] <- choleskyResults
   allResults[["luResults"]] <- luResults
   allResults[["qrResults"]] <- qrResults

   return(allResults)
 
}


#' Performs microbenchmarking of sparse matrix kernels specified by an input
#' vector 
#' 
#' \code{PerformSparseMatrixKernelMicrobenchmarking} performs microbenchmarking
#' of sparse matrix kernels specified by the input vector of
#' \code{SparseMatrixMicrobenchmark} objects.  Objects with the \code{active}
#' flag set to TRUE indicate that the corresponding microbenchmark will be
#' performed; FALSE indicates that the microbenchmark will be skipped.
#'
#' @param microbenchmarks a vector of
#'   \code{SparseMatrixMicrobenchmark} objects defining the sparse matrix
#'   microbenchmarks to be executed as part of the sparse matrix
#'   benchmark.
#' @param numberOfThreads the number of threads the microbenchmarks are
#'   intended to be executed with; the value is for display purposes only as
#'   the number of threads used is assumed to be controlled through environment
#'   variables
#' @param runIdentifier a character string specifying the suffix to be
#'   appended to the base of the file name of the output CSV format files
#' @param resultsDirectory a character string specifying the directory
#'   where all of the CSV performance results files will be saved
#' @return a data frame containing the benchmark name, user, system, and
#'   elapsed (wall clock) times of each performance trial for each
#'   microbenchmark
PerformSparseMatrixKernelMicrobenchmarking <- function(microbenchmarks,
   numberOfThreads, runIdentifier, resultsDirectory) {

   microbenchmarkResults <- NULL

   if (length(microbenchmarks) > 0) {
      for (i in 1:length(microbenchmarks)) {
         if (microbenchmarks[[i]]$active) {

            benchmarkName <- microbenchmarks[[i]]$benchmarkName
            matrixObjectName <- microbenchmarks[[i]]$matrixObjectName

            # The matrices are read in to the global environment so that they
            # only have to be read from storage once.
            loadSuccessful <- tryCatch({
               if (!is.na(matrixObjectName)) {
                  utils::data(list=c(matrixObjectName))
               }

               TRUE
            }, warning = function(war) {
               msg <- sprintf("ERROR: data() threw a warning -- %s", war)
               write(msg, stderr())
               return(FALSE)
            }, error = function(err) {
               msg <- sprintf("ERROR: data() threw an error -- %s", err)
               write(msg, stderr())
               return(FALSE)
            })

            if (loadSuccessful) {
               resultsFrame <- MicrobenchmarkSparseMatrixKernel(microbenchmarks[[i]], numberOfThreads, resultsDirectory, runIdentifier)
               microbenchmarkResults <- rbind(microbenchmarkResults, resultsFrame)
              
               if (!is.na(matrixObjectName)) {
                  remove(list=c(matrixObjectName), envir=.GlobalEnv)
               }

               invisible(gc())
            } else {
               microbenchmarkResults[[benchmarkName]] <- NULL
               msg <- sprintf("ERROR: data() failed to read sparse matrix '%s', skipping microbenchmark '%s'",
                  microbenchmarks[[i]]$matrixObjectName,
                  microbenchmarks[[i]]$benchmarkName)
               write(msg, stderr())
            }
         }
      }
   }

   return (microbenchmarkResults)
}


#' Initializes the vector of default sparse matrix-vector microbenchmarks
#'
#' \code{SparseMatrixVectorDefaultMicrobenchmarks} defines the default sparse
#' matrix-vector microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse
#' matrix-vector microbenchmarks cover a variety of matrices of different
#' dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item laplacian7pt_100 -- 100x100x100 7-point Laplacian operator
#'   \item laplacian7pt_200 -- 200x200x200 7-point Laplacian operator
#'   \item ca2010 -- DIMACS10/ca2010 710145x710145 undirected graph matrix
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerate
#'   in the description.
#' @family sparse matrix default microbenchmarks
#' @export
SparseMatrixVectorDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["laplacian7pt_100"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "matvec_laplacian7pt_100",
      benchmarkDescription = "sparse matrix-vector mult. with 100x100x100 7-point Laplacian operator",
      csvResultsBaseFileName = "matvec_laplacian7pt_100",
      matrixObjectName = "laplacian7pt_100",
      numberOfRows = as.integer(1000000),
      numberOfColumns = as.integer(1000000),
      numberOfNonzeros = as.integer(6940000),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseMatrixVectorAllocator,
      benchmarkFunction = SparseMatrixVectorBenchmark
   )

   microbenchmarks[["laplacian7pt_200"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "matvec_laplacian7pt_200",
      benchmarkDescription = "Sparse matrix-vector mult. with 200x200x200 7-point Laplacian operator",
      csvResultsBaseFileName = "matvec_laplacian7pt_200",
      matrixObjectName = "laplacian7pt_200",
      numberOfRows = as.integer(8000000),
      numberOfColumns = as.integer(8000000),
      numberOfNonzeros = as.integer(55760000),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseMatrixVectorAllocator,
      benchmarkFunction = SparseMatrixVectorBenchmark
   )   

   microbenchmarks[["ca2010"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "matvec_ca2010",
      benchmarkDescription = "Sparse matrix-vector mult. with undirected weighted graph matrix ca2010 from the University of Florida Sparse Matrix Collection DIMACS10 matrix group",
      csvResultsBaseFileName = "matvec_ca2010",
      matrixObjectName = "ca2010",
      numberOfRows = as.integer(710145),
      numberOfColumns = as.integer(710145),
      numberOfNonzeros = as.integer(3489366),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseMatrixVectorAllocator,
      benchmarkFunction = SparseMatrixVectorBenchmark
   )

   return (microbenchmarks)
}


#' Initializes the vector of default sparse Cholesky factorization
#' microbenchmarks
#'
#' \code{SparseCholeskyDefaultMicrobenchmarks} defines the default sparse
#' Cholesky factorization microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse
#' Cholesky factorization microbenchmarks cover a variety of matrices of
#' different dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item ct20stif -- Boeing structural matrix with 2600295 nonzeros
#'   \item Andrews -- computer vision matrix with 760154
#'   \item G3_circuit -- AMD circuit simulation matrix with 7660826 nonzeros
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerated
#'   in the description.
#' @family sparse matrix default microbenchmarks
#' @export
SparseCholeskyDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["ct20stif"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "cholesky_ct20stif",
      benchmarkDescription = "Cholesky factorization of ct20stif matrix from University of Florida Sparse Matrix Collection Boeing group; CT20 engine block -- stiffness matrix, Boeing",
      csvResultsBaseFileName = "cholesky_ct20stif",
      matrixObjectName = "ct20stif",
      numberOfRows = as.integer(52329),
      numberOfColumns = as.integer(52329),
      numberOfNonzeros = as.integer(2600295),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseCholeskyAllocator,
      benchmarkFunction = SparseCholeskyBenchmark
   )

   microbenchmarks[["Andrews"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "cholesky_Andrews",
      benchmarkDescription = "Cholesky factorization of Andrews matrix from University of Florida Sparse Matrix Collection Andrews group; Eigenvalue problem, Stuart Andrews, Brown Univ.",
      csvResultsBaseFileName = "cholesky_Andrews",
      matrixObjectName = "Andrews",
      numberOfRows = as.integer(60000),
      numberOfColumns = as.integer(60000),
      numberOfNonzeros = as.integer(760154),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseCholeskyAllocator,
      benchmarkFunction = SparseCholeskyBenchmark
   )

   microbenchmarks[["G3_circuit"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "cholesky_G3_circuit",
      benchmarkDescription = "Cholesky factorization of G3_circuit matrix from University of Florida Sparse Matrix Collection AMD group; circuit simulation problem, Ufuk Okuyucu, AMD, Inc.",
      csvResultsBaseFileName = "cholesky_G3_circuit",
      matrixObjectName = "G3_circuit",
      numberOfRows = as.integer(1585478),
      numberOfColumns = as.integer(1585478),
      numberOfNonzeros = as.integer(7660826),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseCholeskyAllocator,
      benchmarkFunction = SparseCholeskyBenchmark
   )

   return (microbenchmarks)
}


#' Initializes the vector of default sparse LU factorization microbenchmarks
#'
#' \code{SparseLuDefaultMicrobenchmarks} defines the default sparse LU
#' factorization microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse LU
#' factorization microbenchmarks cover a variety of matrices of different
#' dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item circuit5M_dc -- Freescale DC circuit simulation matrix 2600295
#'     nonzeros
#'   \item stomach -- 3D electro-physical model matrix with 3021648 nonzeros
#'   \item torso3 -- 3D electro-physical model matrix with 4429042 nonzeros
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerated
#'   in the description.
#' @family sparse matrix default microbenchmarks
#' @export
SparseLuDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["circuit5M_dc"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "lu_circuit5M_dc",
      benchmarkDescription = "LU decomposition of circuit5M_dc matrix from University of Florida Sparse Matrix Collection Freescale group; Large circuit (DC analysis) K. Gullapalli, Freescale Semiconductor",
      csvResultsBaseFileName = "lu_circuit5M_dc",
      matrixObjectName = "circuit5M_dc",
      numberOfRows = as.integer(3523317),
      numberOfColumns = as.integer(3523317),
      numberOfNonzeros = as.integer(14865409),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseLuAllocator,
      benchmarkFunction = SparseLuBenchmark
   )

   microbenchmarks[["stomach"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "lu_stomach",
      benchmarkDescription = "LU decomposition of stomach matrix from University of Florida Sparse Matrix Collection Norris group; S.Norris, Univ. Auckland. 3D electro-physical model of a duodenum",
      csvResultsBaseFileName = "lu_stomach",
      matrixObjectName = "stomach",
      numberOfRows = as.integer(213360),
      numberOfColumns = as.integer(213360),
      numberOfNonzeros = as.integer(3021648),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseLuAllocator,
      benchmarkFunction = SparseLuBenchmark
   )

   microbenchmarks[["torso3"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "lu_torso3",
      benchmarkDescription = "LU decomposition of torso3 matrix from University of Florida Sparse Matrix Collection Norris group; S.Norris, Univ Auckland. finite diff. electro-phys.  3D model of torso",
      csvResultsBaseFileName = "lu_torso3",
      matrixObjectName = "torso3",
      numberOfRows = as.integer(259156),
      numberOfColumns = as.integer(259156),
      numberOfNonzeros = as.integer(4429042),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseLuAllocator,
      benchmarkFunction = SparseLuBenchmark
   )

   return (microbenchmarks)
}


#' Initializes the vector of default sparse QR factorization microbenchmarks
#'
#' \code{SparseQrDefaultMicrobenchmarks} defines the default sparse QR
#' factorization microbenchmarks to be executed by the
#' \code{\link{SparseMatrixBenchmark}} function.  The current sparse QR
#' factorization microbenchmarks cover a variety of matrices of different
#' dimensions and number of non-zero values.  They are as follows:
#' \enumerate{
#'   \item Maragal_6 -- rank deficient least squares matrix of 537694 nonzeros
#'   \item landmark -- least squares matrix of 1146848
#' }
#' See the documentation for the
#' \code{\link{SparseMatrixMicrobenchmark}} class for more details.
#'
#' @return a vector of \code{SparseMatrixMicrobenchmark} objects defining the
#'   microbenchmarks to be executed.  The microbenchmarks appear in the order
#'   listed in the function description and are assigned the names enumerated
#'   in the description.
#'   \code{\link{SparseQrDefaultMicrobenchmarks}}
#' @family sparse matrix default microbenchmarks
#' @export
SparseQrDefaultMicrobenchmarks <- function() {
   microbenchmarks <- list()
   microbenchmarks[["Maragal_6"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "qr_Maragal_6",
      benchmarkDescription = "QR factorization of Maragal_6 matrix from University of Florida Sparse Matrix Collection NYPA group; rank deficient least squares problem, D. Maragal, NY Power Authority",
      csvResultsBaseFileName = "qr_Maragal_6",
      matrixObjectName = "Maragal_6",
      numberOfRows = as.integer(21255),
      numberOfColumns = as.integer(10152),
      numberOfNonzeros = as.integer(537694),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseQrAllocator,
      benchmarkFunction = SparseQrBenchmark
   )

   microbenchmarks[["landmark"]] <- methods::new(
      "SparseMatrixMicrobenchmark",
      active = TRUE,
      benchmarkName = "qr_landmark",
      benchmarkDescription = "QR factorization of landmark matrix from University of Florida Sparse Matrix Collection Pereyra group; Matrix from Victor Pereyra, Stanford University",
      csvResultsBaseFileName = "qr_landmark",
      matrixObjectName = "landmark",
      numberOfRows = as.integer(71952),
      numberOfColumns = as.integer(2704),
      numberOfNonzeros = as.integer(1146848),
      numberOfTrials = as.integer(c(3)),
      numberOfWarmupTrials = as.integer(c(1)),
      allocatorFunction = SparseQrAllocator,
      benchmarkFunction = SparseQrBenchmark
   )

   return (microbenchmarks)
}
